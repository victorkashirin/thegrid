<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VCV Rack Module Search</title>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
      color: #333;
    }

    .container {
      max-width: 800px;
      margin: 20px auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #6070d8;
      /* Green */
    }

    #search-input {
      width: calc(100% - 340px); /* Adjusted width to accommodate other elements */
      padding: 10px;
      margin-bottom: 20px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      box-sizing: border-box;
      font-family: 'Inter', sans-serif;
      display: inline-block;
    }

    #size-input {
      width: 70px; /* Reduced width */
      padding: 10px;
      margin-bottom: 20px;
      margin-left: 8px; /* Slightly reduced margin */
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      box-sizing: border-box;
      font-family: 'Inter', sans-serif;
      display: inline-block;
    }

    #size-comparison {
      width: 90px; /* Reduced width */
      padding: 10px;
      margin-bottom: 20px;
      margin-left: 8px; /* Slightly reduced margin */
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
      box-sizing: border-box;
      font-family: 'Inter', sans-serif;
      display: inline-block;
      background-color: white;
    }

    #size-input:focus, #size-comparison:focus {
      outline: none;
      border-color: #4CAF50;
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }

    #reset-button {
      padding: 10px 15px; /* Reduced padding */
      margin-bottom: 20px;
      margin-left: 8px; /* Slightly reduced margin */
      border: 1px solid #4CAF50;
      border-radius: 4px;
      font-size: 16px;
      font-family: 'Inter', sans-serif;
      background-color: white;
      color: #4CAF50;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      white-space: nowrap; /* Prevent button text from wrapping */
    }

    #reset-button:hover {
      background-color: #4CAF50;
      color: white;
    }

    #reset-button:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
    }

    #results-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
      min-height: 100px;
      /* Give it some initial height */
    }

    .result-card {
      background-color: #f9f9f9;
      padding: 15px;
      border: 1px solid #eee;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      display: flex;
      /* Use flexbox for vertical alignment */
      flex-direction: column;
      align-items: center;
      /* Center items horizontally */
      text-align: center;
    }

    .result-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .result-card img {
      width: 100%;
      border-radius: 4px;
      margin-bottom: 10px;
      height: auto;
      /* Maintain aspect ratio */
      max-height: 250px;
      /* Limit image height */
      object-fit: contain;
      /* Ensure image fits within container */
    }

    .result-card h3 {
      margin: 0 0 5px 0;
      color: #4CAF50;
      /* Green */
      font-size: 1.2em;
      font-weight: 600;
    }

    .result-card p {
      margin: 0 0 5px 0;
      color: #555;
      font-size: 0.9em;
    }

    .status-message {
      /* Combined no-results and loading */
      text-align: center;
      padding: 15px;
      background-color: #fff;
      border-radius: 4px;
      border: 1px solid #ddd;
      margin-top: 20px;
      display: none;
      /* Hidden by default */
    }

    #load-more-trigger {
      height: 40px;
      /* Increased height for better trigger */
      margin-top: 20px;
      width: 100%;
      /* background-color: rgba(0, 0, 255, 0.1); */
      /* Optional: For debugging */
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>VCV Rack Module Search</h1>
    <div>
      <input type="text" id="search-input" placeholder="Search for modules...">
      <input type="number" id="size-input" placeholder="Size" min="1">
      <select id="size-comparison">
        <option value="max">Max</option>
        <option value="min">Min</option>
        <option value="exact">Exact</option>
      </select>
      <button id="reset-button">Reset</button>
    </div>
    <div id="results-count" style="margin-top: 10px; margin-bottom: 10px; font-size: 14px;"></div>
    <div id="status-message" class="status-message">Loading modules...</div>
    <div id="results-container"></div>
    <div id="load-more-trigger"></div> <!-- Element to observe for scrolling -->
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const searchInput = document.getElementById('search-input');
      const resultsContainer = document.getElementById('results-container');
      const statusMessage = document.getElementById('status-message');
      const loadMoreTrigger = document.getElementById('load-more-trigger');

      const RESULTS_BATCH_SIZE = 30; // Number of results to load initially and per scroll

      let allModules = [];        // Stores all modules from JSON
      let currentResultSet = [];  // Stores the current list being displayed (all or search results)
      let fuse;                   // Fuse.js instance
      let numDisplayedResults = 0;// Counter for currently displayed items
      let isLoading = false;      // Flag to prevent multiple simultaneous loads
      let observer;               // IntersectionObserver instance
      let lastSearchQuery = '';   // Store the last search query
      let lastSizeFilter = {      // Store the last size filter
        size: '',
        comparison: 'min'
      };

      // --- Utility Functions ---

      function showStatus(message, isError = false) {
        statusMessage.textContent = message;
        statusMessage.style.color = isError ? 'red' : '#555';
        statusMessage.style.display = 'block';
      }

      function hideStatus() {
        statusMessage.style.display = 'none';
      }

      // --- Data Fetching ---

      function fetchJsonData(filePath) {
        isLoading = true;
        showStatus('Loading modules...');
        hideLoadMoreTrigger(); // Hide trigger while loading initial data
        return fetch(filePath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .then(jsonData => {
            // Transform the new format into the expected list of dictionaries
            if (jsonData.headers && Array.isArray(jsonData.data)) {
              // New format detected - transform it
              return jsonData.data.map(row => {
                const obj = {};
                jsonData.headers.forEach((key, index) => {
                  obj[key] = row[index];
                });
                return obj;
              });
            }
            // If it's already in the old format (array of objects), return as is
            return jsonData;
          })
          .catch(error => {
            console.error('Error fetching JSON:', error);
            showStatus('Failed to load module data. Please try refreshing.', true);
            return null; // Indicate failure
          })
          .finally(() => {
            isLoading = false;
            // Status will be updated by the calling function
          });
      }

      // --- Display Logic ---

      function createResultCard(item) {
        const card = document.createElement('div');
        card.className = 'result-card';
        // Use item.item for Fuse results, item directly for initial load
        const moduleData = item.item ? item.item : item;
        const score = item.score; // Get the score if it exists (from Fuse result)
        const imageUrl = `images/${moduleData.plugin_slug}/${moduleData.module_slug}.webp`;

        let scoreHtml = '';
        if (score !== undefined) {
          // Format score to 3 decimal places
          scoreHtml = `<p style="font-size: 0.8em; color: #888;">Score: ${score.toFixed(8)}</p>`;
        }

        card.innerHTML = `
                    <img src="${imageUrl}" alt="${moduleData.module_name}" loading="lazy">
                    <h3>${moduleData.module_name}</h3>
                    <p>Plugin: ${moduleData.plugin_name}</p>
                    ${scoreHtml}
                    <p>${moduleData.description || ''}</p>
                `;
        // Handle missing images gracefully
        const img = card.querySelector('img');
        img.onerror = () => {
          img.style.display = 'none'; // Hide broken image icon
          // Optionally add a placeholder or text
          const placeholder = document.createElement('p');
          placeholder.textContent = '[No Image]';
          placeholder.style.marginTop = '10px';
          card.insertBefore(placeholder, card.querySelector('h3'));
        };
        return card;
      }

      function displayBatch() {
        if (isLoading) return; // Don't load if already loading
        isLoading = true;

        const fragment = document.createDocumentFragment();
        const nextBatchEnd = Math.min(numDisplayedResults + RESULTS_BATCH_SIZE, currentResultSet.length);

        for (let i = numDisplayedResults; i < nextBatchEnd; i++) {
          fragment.appendChild(createResultCard(currentResultSet[i]));
        }

        resultsContainer.appendChild(fragment);
        numDisplayedResults = nextBatchEnd;

        // Hide trigger and disconnect observer if all items are displayed
        if (numDisplayedResults >= currentResultSet.length) {
          hideLoadMoreTrigger();
          if (observer) {
            observer.disconnect();
          }
        } else {
          showLoadMoreTrigger(); // Ensure trigger is visible if more items exist
        }

        // Short delay to allow rendering before allowing next load
        setTimeout(() => {
          isLoading = false;
        }, 100);
      }

      function resetAndDisplayFirstBatch(resultSet) {
        currentResultSet = resultSet;
        resultsContainer.innerHTML = ''; // Clear previous results
        numDisplayedResults = 0;
        hideStatus(); // Clear status message initially

        // Update results count
        const resultsCount = document.getElementById('results-count');
        resultsCount.textContent = `Found ${resultSet.length} module${resultSet.length !== 1 ? 's' : ''}`;

        if (observer) {
          observer.disconnect(); // Disconnect previous observer if exists
        }

        if (currentResultSet.length === 0) {
          showStatus('No matching modules found.');
          hideLoadMoreTrigger();
        } else {
          displayBatch(); // Display the first batch
          // Only setup observer if there are more results to load
          if (numDisplayedResults < currentResultSet.length) {
            setupIntersectionObserver();
            showLoadMoreTrigger();
          } else {
            hideLoadMoreTrigger();
          }
        }
      }

      // --- Search Logic ---

      function filterBySize(modules) {
        const sizeInput = document.getElementById('size-input');
        const sizeComparison = document.getElementById('size-comparison');
        const size = sizeInput.value.trim();
        const comparison = sizeComparison.value;

        if (!size) return modules; // If no size specified, return all modules

        const sizeNum = parseInt(size);
        return modules.filter(module => {
          const moduleSize = parseInt(module.size) || 0;
          switch (comparison) {
            case 'min':
              return moduleSize >= sizeNum;
            case 'max':
              return moduleSize <= sizeNum;
            case 'exact':
              return moduleSize === sizeNum;
            default:
              return true;
          }
        });
      }

      function performSearch(query) {
        if (!fuse) {
          showStatus('Module data is still loading...', true);
          return;
        }

        // Store current filter values
        lastSearchQuery = query;
        lastSizeFilter = {
          size: document.getElementById('size-input').value.trim(),
          comparison: document.getElementById('size-comparison').value
        };

        // First apply size filter to all modules
        let filteredModules = filterBySize(allModules);

        if (query === '') {
          // If query is empty, show size-filtered modules (already sorted by timestamp)
          resetAndDisplayFirstBatch(filteredModules);
        } else {
          // Create new Fuse instance with filtered modules
          const filteredFuse = new Fuse(filteredModules, fuseOptions);
          const results = filteredFuse.search(query);
          resetAndDisplayFirstBatch(results);
        }
      }

      function resetFilters() {
        // Clear search input
        searchInput.value = '';
        
        // Clear size input
        document.getElementById('size-input').value = '';
        
        // Reset comparison to default
        document.getElementById('size-comparison').value = 'max';
        
        // Reset stored values
        lastSearchQuery = '';
        lastSizeFilter = {
          size: '',
          comparison: 'max'
        };
        
        // Show all modules
        resetAndDisplayFirstBatch(allModules);
      }

      // --- Intersection Observer Logic ---

      function hideLoadMoreTrigger() {
        loadMoreTrigger.style.display = 'none';
      }
      function showLoadMoreTrigger() {
        loadMoreTrigger.style.display = 'block';
      }

      function handleIntersection(entries) {
        // Use entries[0] as we observe only one element
        if (entries[0].isIntersecting && !isLoading && numDisplayedResults < currentResultSet.length) {
          // console.log('Loading more...'); // For debugging
          displayBatch(); // Load the next batch of results
        }
      }

      function setupIntersectionObserver() {
        // Ensure previous observer is disconnected before creating a new one
        if (observer) {
          observer.disconnect();
        }

        const options = {
          root: null, // Use the viewport as the root
          rootMargin: '0px',
          threshold: 0.1 // Trigger when 10% of the target is visible
        };
        observer = new IntersectionObserver(handleIntersection, options);
        observer.observe(loadMoreTrigger); // Start observing the trigger element
      }

      // --- Initialization ---

      // Fuse.js options
      const fuseOptions = {
        keys: [
          { name: 'module_name', weight: 7.0 }, // Prioritize module name even more
          { name: 'plugin_name', weight: 3.0 }, // Slightly less boost for plugin name
          { name: 'description', weight: 0.5 }, // Keep description weight low
          { name: 'tags', weight: 0.5 }        // Keep tags weight low
        ],
        includeScore: true,
        shouldSort: true,
        threshold: 0.5, // Make threshold even stricter
        minMatchCharLength: 3,
        distance: 3, // Reduce fuzzy search distance significantly
      };

      // Load data and initialize
      fetchJsonData('search_file.json') // Updated to use the new file
        .then(jsonData => {
          if (!jsonData) return; // Stop if fetching failed

          allModules = jsonData;

          // Sort all modules by timestamp in descending order once after loading
          allModules.sort((a, b) => {
            // Handle missing timestamps by treating them as oldest
            const timestampA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
            const timestampB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
            return timestampB - timestampA; // Descending order
          });

          if (allModules.length === 0) {
            showStatus('No modules found in the data source.', true);
            hideLoadMoreTrigger();
            return;
          }

          // Initialize Fuse.js
          fuse = new Fuse(allModules, fuseOptions);

          // Initial display (first batch of all modules)
          resetAndDisplayFirstBatch(allModules);
          // Status is hidden within resetAndDisplayFirstBatch if successful

        }); // No .finally here, status handled within functions

      // Event listeners for search and filter inputs
      let debounceTimer;
      searchInput.addEventListener('input', function () {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          performSearch(this.value.trim());
        }, 250);
      });

      document.getElementById('size-input').addEventListener('input', function() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          performSearch(searchInput.value.trim());
        }, 250);
      });

      document.getElementById('size-comparison').addEventListener('change', function() {
        performSearch(searchInput.value.trim());
      });

      // Add reset button event listener
      document.getElementById('reset-button').addEventListener('click', resetFilters);

    });
  </script>
</body>

</html>